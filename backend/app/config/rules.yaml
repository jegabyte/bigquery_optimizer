version: 2
rules:
  - id: NO_SELECT_STAR
    name: Avoid SELECT *
    severity: warning
    enabled: true
    requires_metadata: false
    detection_instructions: >
      Flag if any SELECT list contains '*' (including 't.*'), except COUNT(*),
      SELECT * EXCEPT(...), or SELECT * REPLACE(...).
    remediation_instructions: >
      Replace '*' with the specific columns needed to reduce bytes scanned.
    bad_examples:
      - "SELECT * FROM `project.dataset.table`"
      - "SELECT t.* FROM `project.dataset.table` AS t"
    good_examples:
      - "SELECT id, name, created_at FROM `project.dataset.table`"

  - id: MISSING_PARTITION_FILTER
    name: Missing partition filter
    severity: error
    enabled: true
    requires_metadata: true
    detection_instructions: >
      For each referenced partitioned table, check whether the WHERE clause
      filters on the partitioning column (or on _PARTITIONTIME/_PARTITIONDATE for
      ingestion-time partitioned tables). If none, flag.
    remediation_instructions: >
      Add a WHERE filter on the partitioning column (or _PARTITIONTIME/_PARTITIONDATE)
      to enable partition pruning.
    bad_examples:
      - "SELECT id FROM `p.d.t`"
    good_examples:
      - "SELECT id FROM `p.d.t` WHERE dt BETWEEN '2025-07-01' AND '2025-07-31'"

  - id: NON_CONSTANT_PARTITION_FILTER
    name: Non-constant partition filter
    severity: warning
    enabled: true
    requires_metadata: true
    detection_instructions: >
      If the partition filter is non-constant (derived from another field,
      subquery, or expression BigQuery can’t treat as constant), flag because
      it prevents partition pruning.
    remediation_instructions: >
      Use a constant or parameterized literal range on the partition column.
    bad_examples:
      - "WHERE DATE(dt) = DATE(other_col)"
      - "WHERE _TABLE_SUFFIX IN (SELECT suffix FROM params)"
    good_examples:
      - "WHERE dt BETWEEN @start_date AND @end_date"

  - id: FUNCTION_ON_PARTITION_COLUMN
    name: Function on partition column prevents pruning
    severity: warning
    enabled: true
    requires_metadata: true
    detection_instructions: >
      If the WHERE clause wraps the partition column in a function (CAST, DATE(),
      EXTRACT, arithmetic), flag as it disables pruning.
    remediation_instructions: >
      Compare directly on the partition column using range predicates without
      wrapping it in a function.
    bad_examples:
      - "WHERE DATE(dt_ts) = '2025-07-01'"
      - "WHERE customer_id + 1 BETWEEN 30 AND 50"
    good_examples:
      - "WHERE dt_ts >= TIMESTAMP('2025-07-01') AND dt_ts < TIMESTAMP('2025-07-02')"
      - "WHERE customer_id BETWEEN 30 AND 50"

  - id: CLUSTER_FILTER_COMPLEX
    name: Cluster pruning disabled by complex filter
    severity: warning
    enabled: true
    requires_metadata: true
    detection_instructions: >
      If a clustered column is used in a complex filter expression (wrapped in a
      function or compared to another column), flag because block pruning won’t apply.
    remediation_instructions: >
      Filter directly on the clustered column (simple comparisons/ranges).
    bad_examples:
      - "WHERE CAST(customer_id AS STRING) = '10000'"
      - "WHERE customer_id = other_table.order_id"
    good_examples:
      - "WHERE customer_id = 10000"

  - id: WILDCARD_TABLE_NO_SUFFIX_FILTER
    name: Wildcard table without _TABLE_SUFFIX filter
    severity: error
    enabled: true
    requires_metadata: false
    detection_instructions: >
      If FROM references a wildcard table (e.g., table* or `events_*`) and the
      query does not filter _TABLE_SUFFIX (or scans an obviously huge range), flag.
    remediation_instructions: >
      Add a WHERE filter on _TABLE_SUFFIX to restrict scanned tables (and use
      the most granular prefix possible).
    bad_examples:
      - "FROM `p.d.events_*`"
    good_examples:
      - "FROM `p.d.events_*` WHERE _TABLE_SUFFIX BETWEEN '20250701' AND '20250707'"

  - id: EXCESSIVE_WILDCARD_SCOPE
    name: Excessive wildcard scope
    severity: warning
    enabled: true
    requires_metadata: false
    detection_instructions: >
      If a wildcard table is used with an overly broad suffix range (months/years)
      where a narrower range is plausible from context, flag.
    remediation_instructions: >
      Narrow the _TABLE_SUFFIX range or replace shards with time-partitioned tables.

  - id: CROSS_JOIN_WARNING
    name: Cross join detected
    severity: error
    enabled: true
    requires_metadata: false
    detection_instructions: >
      Detect explicit CROSS JOIN, or implicit cross join (comma-separated tables)
      or UNNEST cross join lacking a restrictive predicate; flag due to potential
      row explosion.
    remediation_instructions: >
      Use an explicit JOIN with ON/USING keys, pre-aggregate, or filter prior to join.
    bad_examples:
      - "SELECT * FROM a, b"
      - "SELECT * FROM a CROSS JOIN b"
    good_examples:
      - "SELECT * FROM a JOIN b ON a.id = b.id"

  - id: SELF_JOIN_ANTIPATTERN
    name: Self-join likely anti-pattern
    severity: warning
    enabled: true
    requires_metadata: false
    detection_instructions: >
      If a table is joined to itself to compute row-dependent relationships,
      flag and suggest window functions or PIVOT instead.
    remediation_instructions: >
      Use analytic/window functions or PIVOT to avoid squaring output rows.
    bad_examples:
      - "SELECT * FROM t a JOIN t b ON a.grp = b.grp"
    good_examples:
      - "SELECT a.*, ROW_NUMBER() OVER(PARTITION BY grp ORDER BY ts) rn FROM t a"

  - id: PREAGG_BEFORE_JOIN
    name: No pre-aggregation before large join
    severity: warning
    enabled: true
    requires_metadata: true
    detection_instructions: >
      If two large tables are joined without filtering or pre-aggregating the
      high-cardinality side, flag.
    remediation_instructions: >
      Aggregate or filter early to reduce data volume before joining.
    bad_examples:
      - "SELECT u.*, c.* FROM users u JOIN comments c ON u.id=c.user_id"
    good_examples:
      - |
        WITH comments AS (
          SELECT user_id, COUNT(*) AS comments_count
          FROM comments WHERE user_id IS NOT NULL GROUP BY user_id
        )
        SELECT u.*, c.comments_count
        FROM comments c JOIN users u ON c.user_id=u.id

  - id: INEFFICIENT_JOIN_ORDER
    name: Inefficient join pattern/order
    severity: info
    enabled: true
    requires_metadata: true
    detection_instructions: >
      If the largest table is not first in the FROM/JOIN order and the query
      lacks other optimizations, or if join keys are mismatched types, flag as a
      potential inefficiency (note: the optimizer may reorder, treat as guidance).
    remediation_instructions: >
      Start with the largest table; ensure join keys are compatible types; combine
      with pre-aggregation and early filters.

  - id: JOIN_ON_STRING_KEY
    name: Join on wide STRING keys
    severity: info
    enabled: true
    requires_metadata: true
    detection_instructions: >
      If wide STRING columns are used as join keys and INT64 alternatives exist
      (or castable keys), flag as potential cost/perf issue.
    remediation_instructions: >
      Prefer INT64 (or narrower) join keys when feasible to reduce comparison cost.

  - id: ORDER_BY_WITHOUT_LIMIT
    name: ORDER BY without LIMIT
    severity: warning
    enabled: true
    requires_metadata: false
    detection_instructions: >
      If the outermost SELECT has ORDER BY and no LIMIT/FETCH/OFFSET, flag due
      to expensive global sort on large result sets.
    remediation_instructions: >
      Add LIMIT (for top-N) or refactor with window functions and early limiting.
    bad_examples:
      - "SELECT * FROM t ORDER BY ts DESC"
    good_examples:
      - "SELECT * FROM t ORDER BY ts DESC LIMIT 1000"

  - id: ORDER_BY_NOT_OUTERMOST
    name: ORDER BY in non-outer query
    severity: warning
    enabled: true
    requires_metadata: false
    detection_instructions: >
      If ORDER BY occurs mid-query (outside window functions), flag since pushing
      ORDER BY to the outermost query is usually cheaper.
    remediation_instructions: >
      Move ORDER BY to the outermost SELECT or use window functions appropriately.

  - id: REPEATED_CTE_EVALUATIONS
    name: Repeated CTE evaluated multiple times
    severity: warning
    enabled: true
    requires_metadata: false
    detection_instructions: >
      If the same CTE is referenced in multiple places and looks computationally
      heavy, flag because it may be re-evaluated for each reference.
    remediation_instructions: >
      Materialize intermediate results using temporary tables/variables or restructure.

  - id: REGEX_COSTLY_IN_WHERE
    name: Costly REGEXP in WHERE
    severity: warning
    enabled: true
    requires_metadata: false
    detection_instructions: >
      If WHERE uses REGEXP_CONTAINS/EXTRACT heavily on large scans, flag as costly.
    remediation_instructions: >
      Prefer equality/LIKE when possible; or precompute normalized fields and query them.
    bad_examples:
      - "WHERE REGEXP_CONTAINS(title, r'^[A-Z]{3}[0-9]+$')"
    good_examples:
      - "WHERE title LIKE 'ABC%'"

  - id: UNNECESSARY_DISTINCT
    name: Unnecessary DISTINCT
    severity: info
    enabled: true
    requires_metadata: false
    detection_instructions: >
      If DISTINCT is used on columns already unique by key semantics, or to mask
      duplicates from a join, flag as likely unnecessary.
    remediation_instructions: >
      Remove DISTINCT or fix join keys/aggregations to avoid duplicate generation.

  - id: LARGE_RESULT_NO_MATERIALIZATION
    name: Large result without materialization
    severity: info
    enabled: true
    requires_metadata: false
    detection_instructions: >
      If query returns/writes extremely large result sets (e.g., prone to
      "Response too large" or heavy I/O), flag.
    remediation_instructions: >
      Write to a destination table or reduce outputs; page results via API.

  - id: SUBQUERY_IN_WHERE
    name: Subquery in WHERE (replaceable by JOIN/EXISTS)
    severity: warning
    enabled: true
    requires_metadata: false
    detection_instructions: >
      If WHERE has IN/NOT IN subqueries that could be expressed as JOIN/EXISTS
      to reduce re-evaluation or improve clarity, flag.
    remediation_instructions: >
      Replace with JOIN/EXISTS; for NOT IN guard for NULL semantics.

  # (Optional) DML guidance — disabled by default for SELECT-focused linting
  - id: SINGLE_ROW_DML
    name: Single-row DML anti-pattern
    severity: info
    enabled: false
    requires_metadata: false
    detection_instructions: >
      If UPDATE/INSERT statements mutate single rows repeatedly, flag as OLTP anti-pattern.
    remediation_instructions: >
      Batch updates/inserts or use streaming/ELT patterns suited for BigQuery.
